{"version":3,"sources":["../../../../lib/i18n.ts","../../../../app/technician/order/page.tsx","../../../../lib/gpsService.ts"],"sourcesContent":["\"use client\"\n\nimport { useLanguage as useLangProvider, useT as useTProvider } from \"@/components/language-provider\"\n\nexport function useLanguage() {\n  const { lang, setLang } = useLangProvider()\n  const t = useTProvider()\n\n  return {\n    language: lang,\n    setLanguage: setLang,\n    t\n  }\n}\n","\"use client\"\n\nimport { Suspense, useEffect, useState } from \"react\"\nimport { useSearchParams, useRouter } from \"next/navigation\"\nimport {\n  ArrowLeft, Phone, MessageCircle, MapPin, Clock, Camera, CheckCircle, AlertTriangle, FileText, Send, Upload, Calendar,\n  User, Smartphone, Navigation, Timer\n} from \"lucide-react\"\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\"\nimport { Button } from \"@/components/ui/button\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { Textarea } from \"@/components/ui/textarea\"\nimport { Input } from \"@/components/ui/input\"\nimport {\n  Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogFooter\n} from \"@/components/ui/dialog\"\nimport {\n  Select, SelectContent, SelectItem, SelectTrigger, SelectValue\n} from \"@/components/ui/select\"\nimport { doc, getDoc, updateDoc, onSnapshot, arrayUnion, Timestamp, collection, addDoc, query, where, onSnapshot as onSnapshotCol } from \"firebase/firestore\"\nimport { db, auth, storage, isMockMode } from \"@/firebase/firebaseConfig\"\nimport { ref, uploadBytes, getDownloadURL } from \"firebase/storage\"\nimport { useLanguage } from \"@/lib/i18n\"\nimport { cn, logger } from \"@/lib/utils\"\nimport { getCurrentLocation, formatLocation } from \"@/lib/gpsService\"\n\nconst mockUpload = async (file: File) => {\n  return new Promise<string>((resolve) => {\n    setTimeout(() => {\n      resolve(URL.createObjectURL(file))\n    }, 1000)\n  })\n}\n\nfunction TechnicianOrderClient() {\n  const search = useSearchParams()\n  const id = search.get(\"id\") || \"\"\n  const router = useRouter()\n  const { t, language } = useLanguage()\n  const [order, setOrder] = useState<any>(null)\n  const [loading, setLoading] = useState(true)\n  const [note, setNote] = useState(\"\")\n  const [uploading, setUploading] = useState(false)\n  const [statusDialogOpen, setStatusDialogOpen] = useState(false)\n  const [newStatus, setNewStatus] = useState(\"\")\n  const [etaMinutes, setEtaMinutes] = useState<string>(\"\")\n  const [reqDialogOpen, setReqDialogOpen] = useState(false)\n  const [reqName, setReqName] = useState(\"\")\n  const [reqCategory, setReqCategory] = useState<\"spare_part\" | \"additional_service\" | \"\">(\"\")\n  const [reqQty, setReqQty] = useState<string>(\"1\")\n  const [reqPrice, setReqPrice] = useState<string>(\"\")\n  const [reqReason, setReqReason] = useState(\"\")\n  const [reqPhoto, setReqPhoto] = useState<string>(\"\")\n  const [hasPendingRequests, setHasPendingRequests] = useState(false)\n  const [checkingIn, setCheckingIn] = useState(false)\n  const [checkedIn, setCheckedIn] = useState(false)\n\n  useEffect(() => {\n    if (!id) {\n      setLoading(false)\n      return\n    }\n    setLoading(true)\n    if (isMockMode) {\n      setOrder({\n        id,\n        device: \"Device\",\n        issue: \"Issue\",\n        status: \"pending\",\n        customerPhone: \"\",\n        location: \"\",\n        createdAt: new Date().toISOString()\n      })\n      setHasPendingRequests(false)\n      setLoading(false)\n      return\n    }\n    const docRef = doc(db, \"orders\", id as string)\n    const unsubscribe = onSnapshot(docRef, (docSnap) => {\n      if (docSnap.exists()) {\n        setOrder({ id: docSnap.id, ...docSnap.data() })\n      }\n      setLoading(false)\n    }, (error) => {\n      logger.error(\"Order subscription error:\", error)\n      setLoading(false)\n    })\n    const reqQ = query(collection(db, \"tech_requests\"), where(\"orderId\", \"==\", id), where(\"status\", \"==\", \"pending\"))\n    const unsubReq = onSnapshotCol(reqQ, (snap) => {\n      setHasPendingRequests(snap.size > 0)\n    }, (error) => {\n      logger.error(\"Tech requests subscription error:\", error)\n    })\n    return () => { unsubscribe(); unsubReq() }\n  }, [id])\n\n  const handleStatusUpdate = async () => {\n    if (!newStatus || !order) return\n    if (newStatus === \"completed\" && hasPendingRequests) {\n      alert(t(\"Pending Admin Approval\"))\n      return\n    }\n    if (isMockMode) {\n      setOrder((prev: any) => {\n        if (!prev) return prev\n        const timeline = Array.isArray(prev.timeline) ? prev.timeline : []\n        return {\n          ...prev,\n          status: newStatus,\n          timeline: [...timeline, { status: newStatus, time: new Date().toISOString() }],\n          updatedAt: new Date().toISOString()\n        }\n      })\n      setStatusDialogOpen(false)\n      return\n    }\n    const u = auth.currentUser\n    if (!u || (order.technicianId && order.technicianId !== u.uid)) {\n      alert(t(\"Missing or insufficient permissions\"))\n      return\n    }\n    try {\n      const docRef = doc(db, \"orders\", id as string)\n      await updateDoc(docRef, {\n        status: newStatus,\n        timeline: arrayUnion({ status: newStatus, time: new Date().toISOString() }),\n        updatedAt: Timestamp.now()\n      })\n      setStatusDialogOpen(false)\n    } catch {\n      alert(t(\"Status update failed\"))\n    }\n  }\n\n  const handleSubmitRequest = async () => {\n    if (!order || !reqName || !reqCategory || !reqQty || !reqPrice || !reqReason) return\n    const qty = parseInt(reqQty, 10)\n    const price = parseFloat(reqPrice)\n    if (isNaN(qty) || qty <= 0 || isNaN(price) || price < 0) return\n    if (isMockMode) {\n      setHasPendingRequests(true)\n      setReqDialogOpen(false)\n      setReqName(\"\"); setReqCategory(\"\"); setReqQty(\"1\"); setReqPrice(\"\"); setReqReason(\"\"); setReqPhoto(\"\")\n      alert(t(\"Pending Admin Approval\"))\n      return\n    }\n    const u = auth.currentUser\n    if (!u || (order.technicianId && order.technicianId !== u.uid)) {\n      alert(t(\"Missing or insufficient permissions\"))\n      return\n    }\n    try {\n      await addDoc(collection(db, \"tech_requests\"), {\n        orderId: order.id,\n        technicianId: order.technicianId,\n        technicianName: order.technicianName,\n        partOrServiceName: reqName,\n        category: reqCategory,\n        quantity: qty,\n        estimatedPrice: price,\n        reason: reqReason,\n        photoUrl: reqPhoto || null,\n        status: \"pending\",\n        createdAt: Timestamp.now(),\n        history: [{ action: \"submitted\", by: \"technician\", at: Timestamp.now(), note: reqReason }]\n      })\n      const docRef = doc(db, \"orders\", order.id)\n      await updateDoc(docRef, {\n        status: order.status === \"in_progress\" ? \"waiting_parts\" : order.status,\n        pendingRequestsCount: (order.pendingRequestsCount || 0) + 1,\n        updatedAt: Timestamp.now()\n      })\n      setReqDialogOpen(false)\n      setReqName(\"\"); setReqCategory(\"\"); setReqQty(\"1\"); setReqPrice(\"\"); setReqReason(\"\"); setReqPhoto(\"\")\n      alert(t(\"Pending Admin Approval\"))\n    } catch {\n      alert(t(\"Submit request failed\"))\n    }\n  }\n\n  const handleAddNote = async () => {\n    if (!note.trim() || !order) return\n    const newNote = { text: note, time: new Date().toISOString(), user: \"Technician\" }\n    if (isMockMode) {\n      setOrder((prev: any) => {\n        if (!prev) return prev\n        const notes = Array.isArray(prev.notes) ? prev.notes : prev.notes ? Object.values(prev.notes) : []\n        return { ...prev, notes: [...notes, newNote] }\n      })\n      setNote(\"\")\n      return\n    }\n    const u = auth.currentUser\n    if (!u || (order.technicianId && order.technicianId !== u.uid)) {\n      alert(t(\"Missing or insufficient permissions\"))\n      return\n    }\n    try {\n      const docRef = doc(db, \"orders\", id as string)\n      await updateDoc(docRef, { notes: arrayUnion(newNote) })\n      setNote(\"\")\n    } catch {\n      alert(t(\"Add note failed\"))\n    }\n  }\n\n  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (!e.target.files || !e.target.files[0]) return\n    setUploading(true)\n    const file = e.target.files[0]\n    try {\n      let downloadURL = \"\"\n      if (!storage) {\n        downloadURL = await mockUpload(file)\n      } else {\n        if (isMockMode) {\n          downloadURL = await mockUpload(file)\n        } else {\n          const u = auth.currentUser\n          if (!u || (order?.technicianId && order.technicianId !== u.uid)) {\n            alert(t(\"Missing or insufficient permissions\"))\n            setUploading(false)\n            return\n          }\n          const storageRef = ref(storage, `orders/${id}/${file.name}`)\n          await uploadBytes(storageRef, file)\n          downloadURL = await getDownloadURL(storageRef)\n        }\n      }\n      const newAttachment = { url: downloadURL, name: file.name, type: file.type, time: new Date().toISOString() }\n      if (isMockMode) {\n        setOrder((prev: any) => {\n          if (!prev) return prev\n          const attachments = Array.isArray(prev.attachments) ? prev.attachments : prev.attachments ? Object.values(prev.attachments) : []\n          return { ...prev, attachments: [newAttachment, ...attachments] }\n        })\n      } else {\n        const docRef = doc(db, \"orders\", id as string)\n        await updateDoc(docRef, { attachments: arrayUnion(newAttachment) })\n      }\n    } catch {\n      alert(t(\"File upload failed\"))\n    } finally {\n      setUploading(false)\n    }\n  }\n\n  const handleEtaSave = async () => {\n    if (!etaMinutes || !order) return\n    const minutes = parseInt(etaMinutes, 10)\n    if (isNaN(minutes) || minutes < 0) return\n    const iso = new Date(Date.now() + minutes * 60000).toISOString()\n    if (isMockMode) {\n      setOrder((prev: any) => ({ ...prev, estimatedCompletion: iso, updatedAt: new Date().toISOString() }))\n      setEtaMinutes(\"\")\n      return\n    }\n    const u = auth.currentUser\n    if (!u || (order.technicianId && order.technicianId !== u.uid)) {\n      alert(t(\"Missing or insufficient permissions\"))\n      return\n    }\n    try {\n      const docRef = doc(db, \"orders\", id as string)\n      await updateDoc(docRef, { estimatedCompletion: iso, updatedAt: Timestamp.now() })\n      setEtaMinutes(\"\")\n    } catch {\n      alert(t(\"ETA save failed\"))\n    }\n  }\n\n  const handleCheckIn = async () => {\n    setCheckingIn(true)\n    try {\n      const location = await getCurrentLocation()\n      if (isMockMode) {\n        setOrder((prev: any) => {\n          if (!prev) return prev\n          const notes = Array.isArray(prev.notes) ? prev.notes : prev.notes ? Object.values(prev.notes) : []\n          return {\n            ...prev,\n            checkIn: { lat: location.lat, lng: location.lng, address: location.address || \"\", timestamp: new Date().toISOString() },\n            notes: [...notes, { text: `Checked in at: ${location.address || `${location.lat}, ${location.lng}`}`, time: new Date().toISOString(), user: \"Technician\" }],\n            updatedAt: new Date().toISOString()\n          }\n        })\n        setCheckedIn(true)\n        alert(t(\"Check-in successful!\"))\n      } else {\n        const u = auth.currentUser\n        if (!u || (order?.technicianId && order.technicianId !== u.uid)) {\n          alert(t(\"Missing or insufficient permissions\"))\n          setCheckingIn(false)\n          return\n        }\n        const docRef = doc(db, \"orders\", id as string)\n        await updateDoc(docRef, {\n          checkIn: { lat: location.lat, lng: location.lng, address: location.address || \"\", timestamp: Timestamp.now() },\n          notes: arrayUnion({ text: `Checked in at: ${location.address || `${location.lat}, ${location.lng}`}`, time: new Date().toISOString(), user: \"Technician\" }),\n          updatedAt: Timestamp.now()\n        })\n        setCheckedIn(true)\n        alert(t(\"Check-in successful!\"))\n      }\n    } catch (error: any) {\n      alert(t(\"Check-in failed: \") + error.message)\n    } finally {\n      setCheckingIn(false)\n    }\n  }\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case \"pending\": return \"text-yellow-500 bg-yellow-500/10\"\n      case \"in_progress\": return \"text-blue-500 bg-blue-500/10\"\n      case \"on_way\": return \"text-purple-500 bg-purple-500/10\"\n      case \"completed\": return \"text-green-500 bg-green-500/10\"\n      default: return \"text-gray-500 bg-gray-500/10\"\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen bg-black text-white p-4\">\n      <div className=\"text-center text-white/60\">Order details page requires ?id=ORDER_DOC_ID</div>\n    </div>\n  )\n}\n\nexport default function TechnicianOrderDetails() {\n  return (\n    <Suspense\n      fallback={\n        <div className=\"min-h-screen bg-black text-white p-4\">\n          <div className=\"text-center text-white/60\">Loading...</div>\n        </div>\n      }\n    >\n      <TechnicianOrderClient />\n    </Suspense>\n  )\n}\n","/**\r\n * GPS Service for technician location tracking\r\n * Enables check-in/check-out at customer locations\r\n */\r\n\r\nexport interface LocationData {\r\n    lat: number\r\n    lng: number\r\n    accuracy: number\r\n    timestamp: number\r\n    address?: string\r\n}\r\n\r\nexport interface CheckInRecord {\r\n    orderId: string\r\n    technicianId: string\r\n    type: \"check_in\" | \"check_out\"\r\n    location: LocationData\r\n    timestamp: Date\r\n}\r\n\r\n/**\r\n * Get current GPS location\r\n */\r\nexport function getCurrentLocation(): Promise<LocationData> {\r\n    return new Promise((resolve, reject) => {\r\n        if (!navigator.geolocation) {\r\n            reject(new Error(\"Geolocation is not supported\"))\r\n            return\r\n        }\r\n\r\n        navigator.geolocation.getCurrentPosition(\r\n            async (position) => {\r\n                const { latitude, longitude, accuracy } = position.coords\r\n\r\n                // Optionally reverse geocode\r\n                let address: string | undefined\r\n                try {\r\n                    const response = await fetch(\r\n                        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`\r\n                    )\r\n                    const data = await response.json()\r\n                    address = data.display_name\r\n                } catch (e) {\r\n                    // Ignore geocoding errors\r\n                }\r\n\r\n                resolve({\r\n                    lat: latitude,\r\n                    lng: longitude,\r\n                    accuracy,\r\n                    timestamp: position.timestamp,\r\n                    address\r\n                })\r\n            },\r\n            (error) => {\r\n                reject(new Error(error.message))\r\n            },\r\n            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }\r\n        )\r\n    })\r\n}\r\n\r\n/**\r\n * Calculate distance between two points (Haversine formula)\r\n */\r\nexport function calculateDistance(\r\n    lat1: number,\r\n    lng1: number,\r\n    lat2: number,\r\n    lng2: number\r\n): number {\r\n    const R = 6371 // Earth's radius in km\r\n    const dLat = ((lat2 - lat1) * Math.PI) / 180\r\n    const dLng = ((lng2 - lng1) * Math.PI) / 180\r\n    const a =\r\n        Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n        Math.cos((lat1 * Math.PI) / 180) *\r\n        Math.cos((lat2 * Math.PI) / 180) *\r\n        Math.sin(dLng / 2) *\r\n        Math.sin(dLng / 2)\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\r\n    return R * c // Distance in km\r\n}\r\n\r\n/**\r\n * Check if technician is within range of customer location (in km)\r\n */\r\nexport function isWithinRange(\r\n    techLat: number,\r\n    techLng: number,\r\n    customerLat: number,\r\n    customerLng: number,\r\n    maxDistanceKm: number = 0.5\r\n): boolean {\r\n    const distance = calculateDistance(techLat, techLng, customerLat, customerLng)\r\n    return distance <= maxDistanceKm\r\n}\r\n\r\n/**\r\n * Format location for display\r\n */\r\nexport function formatLocation(location: LocationData): string {\r\n    if (location.address) {\r\n        return location.address\r\n    }\r\n    return `${location.lat.toFixed(6)}, ${location.lng.toFixed(6)}`\r\n}\r\n\r\n/**\r\n * Watch position for real-time tracking\r\n */\r\nexport function watchLocation(\r\n    onUpdate: (location: LocationData) => void,\r\n    onError?: (error: Error) => void\r\n): number | null {\r\n    if (!navigator.geolocation) {\r\n        onError?.(new Error(\"Geolocation is not supported\"))\r\n        return null\r\n    }\r\n\r\n    return navigator.geolocation.watchPosition(\r\n        (position) => {\r\n            onUpdate({\r\n                lat: position.coords.latitude,\r\n                lng: position.coords.longitude,\r\n                accuracy: position.coords.accuracy,\r\n                timestamp: position.timestamp\r\n            })\r\n        },\r\n        (error) => {\r\n            onError?.(new Error(error.message))\r\n        },\r\n        { enableHighAccuracy: true }\r\n    )\r\n}\r\n\r\n/**\r\n * Stop watching location\r\n */\r\nexport function stopWatchingLocation(watchId: number): void {\r\n    navigator.geolocation.clearWatch(watchId)\r\n}\r\n"],"names":[],"mappings":"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"}